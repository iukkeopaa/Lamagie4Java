在前两篇文章中，我们分析了分布式锁是什么、分布式锁能解决什么问题、如何设计一把分布式锁以及如何用 MySQL 来实现一把分布式锁，想必现在你对分布式锁应该不再陌生了，因为它的核心架构以及实现原理我们全都剖析完成了。

从这篇开始，我们就正式进入了非常流行的 Redis 实现分布式锁的各种方案剖析阶段，你会学习到 Redis 实现分布式锁的核心原理是什么，了解到大名鼎鼎的 RedLock（红锁）到底是咋玩的以及它的安全性如何，当然，我们还会介绍其他各种锁，比如：信号量、公平锁、读写锁等，这些锁我们都会基于 Redis 的流行框架 Redisson 来进行讲解与剖析。

至于今天这篇文章，你不仅会学习到 Redis 实现分布式锁都有哪些关键点、实现方式以及每种方式的优缺点，而且你还会学到 Redis 设计分布式锁的核心思想。

下面进入正题，我们先来分析下如果用 Redis 作为分布式锁的话，都应该注意哪些关键点。

# 一、关键点

我认为 Redis 作为分布式锁的关键点有四个：**原子性、过期时间、锁续期**和**正确释放锁**。

看到这四个关键词，可能有的人会一知半解，不用慌，下面我们就来逐个分析它们是什么意思以及有什么作用。

## 1\. 原子性

什么是原子性？在第一篇讲锁的时候我们简单提及了原子性的一些概念性内容，这里我再带你深入剖析下到底什么是原子性。

首先，我们看下如果没有原子性的话会发生什么问题。比如，一个虽老生常谈但也很经典的问题：银行转帐，我给你转了 100，正常情况是我的账户 -100，你的账户 +100。如下伪代码：

```java
public void test() {
    // 我的账号扣减100
    decrMoney(100);

    // 你的账号增加100
    incrMoney(100);
}
```

如果没有原子性，当执行完`decrMoney(100);`的时候突然系统宕机了，那会出现我莫名其妙少了 100 块钱，而你的账号也没增加我这 100，相当于我丢了 100 块钱。肯定不可取。

那原子性是什么意思呢？**要么都成功，要么都失败**。你仔细品这句话，是不是发现上面转账方法如果是原子性的话就没丢100块钱的问题了？

回到主题，为什么我说 Redis 实现分布式锁的关键点之一是原子性呢？

回答这个问题之前，我们需要先知道 Redis 是如何实现一把分布式锁的。**实现分布式锁的核心就是找一个集群内都可见的地方把锁存起来**，知道了这个特点后那就太简单了，那 Redis 实现分布式锁岂不是直接用`redis.set(key, value)`就完事了？是的，看起来确实一个命令就搞定了分布式锁。但是我们在第一讲的时候还说了如果锁没来得及释放结果遇到服务宕机了，就会出现死锁的问题。巧了，Redis 支持给 key 设置过期时间，那我们给锁 key 设置个过期时间不就好了？这样即使服务宕机了，那超过时间后也自动释放了，好像没问题，所以又来一个命令：`redis.expire(key, time, unit);`。

也就是两条命令完成分布式锁：

```redis
redis.set(key, value);
redis.expire(key, time, unit);
```

但这是两条命令，万一加锁成功了，还没设置过期时间呢，服务宕机了，岂不是又回到原点了？依然死锁。那如果我们给它弄成原子的呢？要么都成功，要么都失败。这样不就没问题了嘛，所以我说 Redis 实现分布式锁的关键点之一就是原子性。

## 2\. 过期时间

为什么过期时间也是核心关键点之一呢？这里我们就不重复讲述了，因为上面我们刚分析过的，不带过期时间可能发生死锁，一直无法释放，所以它也是有效避免死锁的一种技术手段。

## 3\. 锁续期

锁续期是什么？字面意思，给锁重新设置过期时间。

为什么需要续期？假设锁过期时间设置了 3s，但是业务代码执行了 4s 还没执行完，那锁过期自动释放了，其他线程在请求接口的时候发现目前没锁，就又加上了锁，这时候不就两个客户端并发执行了吗？相当于还是线程不安全。

那锁续期是如何解决此问题的呢？

**开辟另外一个线程，专门用于锁续期，上锁的时候就起个线程进行死循环续期，核心流程就是判断锁的时间过三分之一了就给他重新续期为上锁时间**。比如设置的锁是 3s，检查超过 1s 了还没执行完，那就重新给这个锁续期为 3s，防止方法没执行完呢，锁先过期了的情况。

有的人可能有疑问：也就是说锁永远都在释放锁的时候才进行过期？那为啥还要设置过期时间？这个上面说过了，防止死锁。

到目前为止，加锁好像没 Bug 了，那该如何释放锁呢？

## 4\. 正确释放锁

**正确释放锁**，啥叫正确？下面我们看个例子。

问题 1：释放锁可能释放了别人的锁。比如，锁设置了 3s，但是业务代码执行了 4s 还没执行完，那锁过期了，其他线程在请求接口的时候又加上了锁，然后第一个执行了 4s 的线程运行完后，释放了第二个线程加的锁，这时候其他线程又能抢锁了，这不安全！

那如何解决呢？引发问题的关键在于业务代码没执行完锁却过期了，那我们有什么办法让锁在业务未执行完成之前不过期？可以进行锁续期，下面是锁续期的伪代码：

```java
private volatile boolean isRunning;

// 抢锁成功
if (RESULT_OK.equals(client.setNxPx(key, value, ttl))) {
    // 续期
    renewalTask = new RenewTask(new IRenewalHandler() {
        @Override
        public void callBack() throws LockException {
            // 刷新值
            client.expire(key, ttl <= 0 ? 10 : ttl);
        }
    }, ttl);
    renewalTask.start();
}

// 续期线程的逻辑
@Override
public void run() {
    while (isRunning) {
        try {
            // 1、续租，刷新值
            call.callBack();
            LOGGER.info("续租成功!");
            // 2、三分之一过期时间续租
            TimeUnit.SECONDS.sleep(this.ttl * 1000 / 3);
        } catch (InterruptedException e) {
            close();
        } catch (LockException e) {
            close();
        }
    }
}

public void close() {
    isRunning = false;
}
```

问题 2：客户端 A 上了锁，客户端 B 搞破坏，上来就 unlock 解锁，这时候直接执行`redis.del(key)`将客户端 A 的锁给释放了。这就相当于释放了别人的锁，这种情况怎么解决呢？

首先我们应该想一个问题：客户端 B 释放锁的时候为什么会释放掉客户端 A 的锁呢？因为锁的 key 肯定是一样的，毕竟锁的是同资源嘛。那么就需要从 value 入手了，解锁前先判断下这个 key 的 value 是不是自己加的，value 不能是线程 ID，因为分布式环境线程 ID 会重复，所以可以换成类似 userID 等业务主键；或者也可以换成随机数，因为加锁、解锁都在一个方法里，解锁的时候是可以得到这个随机数的。其伪代码如下：

```java
// 判断订单 ID 的锁是自己上的方可释放
if((userId).equals(stringRedisTemplate.opsForValue().get(orderId))) {
    stringRedisTemplate.delete(orderId);
}
```

这样行吗？肯定不行的，因为判断里的 Redis 获取操作和 del 操作**是非原子的**，如果你设置了超时时间，而你的业务在超时时间内没有执行完，那么这个锁就会被释放，其他线程拿到锁，以上恰好发生在 get 之后、del 之前，会删除其他的锁，那么是不是就脏读了呢？但是如果有续期的话就不存在此问题。但还是尽量用 lua 脚本，lua 脚本如下：

```java
// 如果get的值等于传进来的值，就给它del
if redis.call("get",KEYS[1])==ARGV[1] then
  return redis.call("del",KEYS[1])
else
  return 0
end 
```

所以，什么叫“正确释放锁”？一言以蔽之：**利用锁续期机制防止出现业务没执行完成锁就到期了、提前被释放的情况，且释放锁的时候还要判断是不是自己加的锁，避免误释放了别人的锁。**

现在 Redis 设计一把分布式锁的“四大神兽”全都搞定了，你是不是会想“终于该到实现的篇幅了”？我只能说你想多了。最开始我就说了，本文只讲解 Redis 实现分布式锁的核心架构和核心原理，至于其具体代码实现后面我们会用 N 篇文章来详细剖析。不要小看实现前的这些基础知识点哦，毕竟夯实基础才能构筑“高楼”，以不变应万变。

接下来我们再看另一个大的问题：Redis 实现分布式锁有哪几种部署方式？

# 二、Redis 实现分布式锁的几种部署方式

Redis 主要有四种实现分布式锁的部署架构，下面我们就对各个架构做一个简单的阐述，需要说明的是，这里并不会涉及到如何部署，毕竟我们不是讲解 Redis 运维，而是讲解分布式锁，不过相信你看完后就会对这四种 Redis 部署方式作为分布式锁的原理和利弊都了如指掌。

## 1\. 单机

直接部署一台 Redis，这就是单机，然后单机上锁。这种方式既有优点，又有缺点。

* 优点：太简单了，不论从部署角度还是使用角度都很方便。
* 缺点：这台机器挂了就 GG 了，整个业务系统都获取不到锁了，也就是**单点故障**了。

## 2\. 哨兵

单点故障时，我们第一时间想到的就是搞几个 Slave 从节点做备份，Redis 里很好地支持了哨兵（Sentinel）模式，接下来我们就分析下。

既然单点故障，那我搞个哨兵（Sentinel），自动主从切换。这下稳了吧？但是还可能会出现新的问题：**锁写到Master后，还没同步到Slave呢，Master挂了Slave选举成了Master，但是Slave里没有锁，其他线程再次能上锁了。不安全。**

## 3\. 集群

集群只是做了 slot 分片，锁还是只写到一个 Master 上，所以它和哨兵（Sentinel）模式会面临同样的问题。

那怎么办？好像怎么搞都不安全，这时候大名鼎鼎的红锁（RedLock）诞生了。

## 4\. 红锁

红锁，也称 RedLock，非常著名！它是 Redis 实现分布式锁**相对**最安全可靠的一种手段。

**红锁的核心思路是：搞几个独立的Master，比如5个，然后挨个加锁，只要超过一半以上（这里是`5 / 2 + 1 = 3`个）就代表加锁成功，然后释放锁的时候也逐台释放。这样的好处在于一台Master挂了的话，还有其他的，所以不耽误，看起来好像完美解决了上面的问题。**

但这样就真的 100% 安全了吗？你可以先思考下这个问题。关于红锁，我们会在后面单独再开一个篇幅来重点分析其细节和核心实现源码。

# 三、Redis 实现分布式锁的优缺点

凡事都有两面性，Redis 实现分布式锁亦然。

其优点包括：

* 大多数互联网企业都在用 Redis，所以无需额外引入其他中间件，节省了成本开销；

* Redis 的性能还是很高的，所以对业务系统的性能影响相对较小；

* Redisson 客户端类库将锁的所有用法都封装了（可重入锁、读写锁、公平锁等），用户调用就完事了，所以支持得比较友好。

另外，其缺点有如下：

* Redis 虽然提供了很多种部署架构，单机、哨兵、集群以及著名的红锁（RedLock），但是没有哪一种是 100% 安全的。

* 红锁（RedLock）虽然是相对最安全的一种方式，但是它极其麻烦，而且对性能的开销也是其他锁的 N 倍，因为需要逐个加锁，需要多次与 Redis 通信。

# 四、总结

本文的知识点可能比较多、比较琐碎，但是每一个知识点都是非常核心、非常关键的，第一遍没读懂就再读一遍，这篇文章是必须要掌握的！

这不仅算是入门篇，更是 Redis 实现分布式锁的核心知识篇。你需要掌握如下的这些知识点。

* Redis 作为分布式锁的四大关键点：原子性、过期时间、锁续期、释放锁。后面代码实现其实就是围绕这四个知识点来做具体开发而已。

* Redis 作为分布式锁有哪几种方式？各有什么利弊？这是面试中常被问到的。

我认为不管你用 Redis 的哪种方式来实现分布式锁，都不是 100% 安全的，那就不用 Redis 做分布式锁了吗？其实不然。我觉得**这主要还得取决于业务**，如果你业务要求必须 100% 不能出问题，那就用 ZooKeeper/etcd 来实现吧。但是据我了解，至少 80% 的互联网公司都不这么强烈要求，大多数还是 Redis 分布式锁。如果公司是银行业务，是与钱打交道的业务，要求尽最大能力来保证安全可靠，那可优先选择 ZooKeeper 来实现分布式锁，但是 ZooKeeper 也真的就 100% 安全吗？这个疑问等后面讲解 ZooKeeper 如何实现分布式锁的时候再来进行讨论和答疑吧。

# 五、拓展阅读

[RedLock官方文献](https://redis.io/topics/distlock "https://redis.io/topics/distlock")