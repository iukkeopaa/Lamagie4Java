前面几讲我们结束了Redis实现分布式锁的核心原理和底层剖析，从今天开始我会以“如何设计一个XXX？”的口吻来讲解每一个高级进阶的知识点，这样好处在于不是那么死板，会先从底层原理开始讲起，然后给出具体实现的思路以及最后会分析Redisson是如何实现的。接下来我们开始高级进阶的第一个知识：如何设计一个分布式公平锁？

# 一、什么是公平锁和非公平锁？

在讲解如何设计一个分布式公平锁之前，我们需要先知道什么叫公平锁以及什么叫非公平锁？他们之间有何区别？先来看看什么是公平锁。

**公平锁**

什么叫公平？举一个生活中的例子：我还记得上高中时候，放学铃声一响，大家以每秒100m的速度冲往食堂，食堂早就有老师提前到达了，去维护秩序，防止插队的情况。这就叫公平，先来后到。杜绝插队。

那放到程序中，公平应该怎么理解呢？我再来举个例子：

比如A、B、C三个线程同时执行`method1()`方法，而`method1()`方法是有锁的，假设线程A先到达的，所以A先抢到锁了，后来线程C比线程B先到一步，那么，线程A执行完业务逻辑释放锁后线程C会继续持有锁而不是线程B，线程B会等到线程C执行完后才有资格获取锁，这就是公平，先来后到，先进先出。

公平锁知道了，那什么是非公平锁呢？

**非公平锁**

老规矩，还是先举一个生活中的例子：假设食堂监督老师今天请假了，没来值班。这时候总会有一堆“校园恶霸”去插队，完全不考虑前面排队人的感受，有可能最后去的但是插队到了最前面，立马打到饭了。这就是非公平，没有顺序可言。

我们放到程序中再来理解下：

比如A、B、C三个线程同时执行`method1()`方法，而`method1()`方法是有锁的，假设线程A先抢到锁了，后来线程B和线程C发现有锁阻塞等待重试了，那么当线程A释放锁后，线程B和线程C会都进行抢锁，谁先抢到锁就算谁的，完全没有排队的概念。

搞懂什么是公平锁和非公平锁后，我们就一起看看如何实现吧～

# 二、公平锁和非公平锁的核心原理

在真正实现公平锁和非公平锁之前，我们需要先掌握公平锁和非公平锁的核心原理，也就是说如果要实现公平锁，那该如何设计呢？

## 1\. 公平锁

我们已经知道公平锁的概念了，其实就是先进行抢锁，一个客户端抢到后，后面的客户端就进入队列排队。概念很好理解，但是问题来了：

* 抢锁成功了，那么这把锁该如何存储呢？
* 有线程持有锁，其他线程又来抢锁，这时候会进行/排队，那么排队队列怎么设计呢？
* 排队队列中的线程等待多久进行下一次尝试抢锁呢？肯定不能无限期等待吧？

下面我们就带着这三个疑问来逐个去分析、去设计，先来看第一个问题：

**抢锁成功后怎么存储？**

我们先回忆下前面几篇讲解Redis如何实现分布式锁的时候是怎么存储的？用的hash结构，大概如下：

```css
myLock: {
    [uuid:threadId]:锁次数
}
```

那公平锁有啥特殊之处吗？肯定没有的，锁状态我们依然可以这样来存储，好处就是这样还能方便的进行锁重入。比如现在线程持有锁hello，那锁的存储结构就是下面这个样子：

```css
{"hello": {[uuid:threadId]:1}}
```

如果这个线程再次加锁了，也就是锁重入了，那么存储如下：

```css
{"hello": {[uuid:threadId]:2}}
```

释放锁的时候也一样，先判断锁次数是不是大于1，是的话就是有锁重入，不能删除，需要减1：

```css
{"hello": {[uuid:threadId]:1}}
```

再次释放，判断锁次数等于1了，也就是没有锁重入了，那就直接del掉了。

至此，锁的存储设计完了，很简单，和之前的存储结构是一样的，没有任何改变，足够满足需求。接下来我们分析第二个问题：

**排队队列怎么设计？**

首先JVM的queue肯定不行，那是单机的。所以只能从Redis下手，Redis哪些数据结构是有序的呢？太简单了，list数据结构呀！所以发生锁冲突的时候就添加到list里，当持有锁的线程执行完后，list里的第一个元素就弹出来去抢锁锁，这样先进先出，绝对公平。至于加锁和锁重入等逻辑都是上面hash结构来办的，这个list只负责公平性。

那是不是有安全性问题呢？

假设并发太高了，都在list排队队列里堆积着，那我业务代码得阻塞多久呀？这谁顶得住。所以需要设置个阻塞时间，超过这个时间就自动移除队列，下次再抢锁的话就再重新加入到list队列里来。那这个过期时间咋搞？

肯定不能直接给list加expire，这样的话list里的所有等待的线程都弹出了，举个例子：假设现在有C和D两个线程在list队列里排队，C要求阻塞的剩余时间还有2s，D要求阻塞的剩余时间还有6s，直接给list加expire的话，那你是加2s呢还是加6s呢？加哪个都会有问题，不安全。那怎么办？那是不是可以单独给C和D添加呢？也就是在发生锁冲突后入队的时候给线程带上呢？

可以是可以，但是我怎么找到哪些是过期的呢？难道我要逐个遍历对比吗？这样性能肯定不好，那我们能不能让他按照阻塞等待时间排序然后再遍历呢？这就是我们的第三个问题：

**队列中的线程无限期等待？**

Redis有个数据结构叫zset支持按照score进行排序，那搞个zset不就解决了吗？把时间当作score，按照score排序，然后进行遍历，遍历对比每一个线程的时间，过期的就弹出队列，移除zset，直到没过期为止。这样就解决了乱序的性能问题了，相当于用空间换时间。优化之前乱序从头遍历到尾的O(n)时间复杂度。

**简单总结下公平锁：**

**公平锁的核心就是三个数据结构：hash存储锁以及重入次数、list进行排队保证公平性、zset来完成锁等待时长。**

公平锁为相信大家已经彻底掌握了其中的设计思想和原理，那非公平锁该如何设计呢？

## 2\. 非公平锁

非公平锁太简单了，无需排队，抢锁过程就是`while(true)`多线程并发的去抢占。所以没有排队队列list以及阻塞时间zset这两个数据结构，就一个hash结构来存储锁即可。我们前面几篇文章分析的加解锁流程都是非公平锁的，忘记的小伙伴再去翻一番。

接下来我们再来看一个问题，也是很重点的问题，面试常考的问题，那就是**你认为公平锁效率高还是非公平锁效率高？**

盲猜也是非公平锁效率高，为啥？因为Redisson默认就是非公平锁，他肯定默认效率高的那一个。那为啥非公平锁效率高于公平锁呢？

其实本质原因是因为公平锁需要加到阻塞队列排队，还需要加到zset，这就额外需要两次redis操作，你在看非公平锁，其他线程来抢锁了，完全不丢到阻塞队列里，我又不是公平的，为啥不直接执行呢？所以直接执行。省去了很多啰嗦的步骤。

以上就是公平锁和非公平锁的全部核心原理了，接下来我们就一起看看Redisson这个成熟的框架是如何实现公平锁和非公平锁的。

# 三、Redisson的公平锁

公平锁的源码不打算逐行讲解，最主要的还是核心原理、设计思想。源码细节无非就是按照完说的设计思想和核心架构的一个具体落地实现，不讲的原因是因为Redisson的公平锁的lua实现七八十行，很难读懂。但是核心原理就是此篇所讲。

感兴趣的可以阅读下：`org.redisson.RedissonFairLock#tryLockInnerAsync`

这里只讲解核心lua语句。

**加锁**

就是一个hash，最后的1表示重入次数。

```ini
"redis.call('hset', KEYS[1], ARGV[2], 1);" +
"redis.call('pexpire', KEYS[1], ARGV[1]);" +
```

**重入**

就是判断是否存在当前线程，存在的话就hincrby 1，加1，然后重新设置过期时间。

```ini
"if redis.call('hexists', KEYS[1], ARGV[2]) == 1 then " +
    "redis.call('hincrby', KEYS[1], ARGV[2],1);" +
    "redis.call('pexpire', KEYS[1], ARGV[1]);" +
    "return nil;" +
"end;" +
```

**排队**

zadd添加到zset中做阻塞时长，然后rpush添加到队列中排队等待。

```ini
"if redis.call('zadd', KEYS[3], timeout, ARGV[2]) == 1 then " +
    "redis.call('rpush', KEYS[2], ARGV[2]);" +
"end;" +
```

**超出等待时长**

```ini
"while true do " +
    "local timeout = tonumber(redis.call('zscore', KEYS[3], firstThreadId2));" +
    "if timeout <= tonumber(ARGV[4]) then " +
        "redis.call('zrem', KEYS[3], firstThreadId2);" +
        "redis.call('lpop', KEYS[2]);" +
    "else " +
        "break;" +
    "end;" +
"end;" +
```

死循环遍历，如果超出了等待时长，就从zset和list中移除掉，直到找到没到时间的那个元素后break。

又到了完美的收官情节了，来个总结吧。

# 四、总结

个人认为本篇幅内容很干，从什么是公平和非公平开始推导如何设计每一个细节到最后如何实现都剖析的一清二楚了，在最后我们还分析了Redisson这个开源框架是如何设计的，发现思想就是我们前面所阐述的那样，我们也学习到公平锁是这篇文章的核心，因为非公平锁之前的文章就已经讲解完了，所以最后对公平锁做个简单的总结，公平锁的核心就是三个数据结构：**hash存储锁以及重入次数、list进行排队保证公平性、zset来完成锁等待时长。** 流程可以用下面这张图来描述：

![redisson-公平锁lock01.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18acc3e6cf2642f3a4f7e7f89e44f388~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1678&h=850&s=119232&e=png&b=ffffff)

最后提前剧透一下，我们下一篇会以然采取这种逐步推导对方式来讲解如何设计一个分布式读写锁。