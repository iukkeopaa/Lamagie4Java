你有没有被以下几个问题困扰过？

* 单位没有分布式调度中心，要写个定时任务，但是现在都是集群部署，结果你发现你的定时任务同时在无数台机器上执行了，造成了数据混乱。
* 要做跟库存相关的系统，比如医疗的进销存卖药、电商的库存等，结果并发量太大导致库存超卖了，库存剩余量出现了负数。

不用困扰了，通过这篇文章你将会明白这几个问题到底是因为什么产生的以及该如何解决。

除此之外，你还会学到面试官常问的分布式锁到底是什么、我们为啥需要它以及它的核心设计思想是什么，同时我还会给出几个分布式锁的常见应用场景，这篇文章是基础，是核心思想，也是之后文章的一个基石。

# 一、为什么需要分布式锁？

假设现在就做个同时在线人数的功能，那我们怎么做？

新手可能立马想到了：

```java
public class Demo {

    // 同时在线人数
    private int onlineCount;

    public void login() {
        // 省略其他逻辑
        onlineCount ++;
    }

    // 获取同时在线人数
    public int getOnlineCount() {
        return onlineCount;
    }
}
```

看起来好简单，就一个全局计数器，每次登陆都 +1，然后提供一个 get 方法来获得在线人数。好像确实实现了我们的需求，但是经验丰富的开发者立马就发现了致命问题：这破玩意线程安全吗？肯定不安全。

为什么说它不安全呢？这主要是因为`onlineCount ++`这个操作不是原子性的，它会编译成`onlineCount = onlineCount +1` ，其实是做了如下3个步骤。

* **读内存到寄存器**：将onlineCount的值从内存中读到CPU的寄存器上。

* **在寄存器中自增**：在CPU的寄存器里进行onlineCount + 1的操作。

* **将数据写回内存**：把寄存器里计算好的值写回内存。

这并不是原子操作，而是三个独立的步骤。假设现在有两个客户端同时执行这段代码，那么客户端 1 和客户端 2 都先把 onlineCount 的值从内存中读到 CPU 的寄存器上，假设都是 0，然后两个客户端又都在寄存器里进行 +1 操作，变成了 1。最后客户端 1 将自增后的数据 1 写回内存，客户端 2 也将自增后的数据 1 写回内存，正常吗？不正常，正确结果应该是 2，结果却是 1。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37b9118797ab41d9b9ee3bb57f336107~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1540&h=846&s=127892&e=png&b=ffffff)

那怎么办呢？**加锁**！

怎么加锁呢？首先想到的就是 synchronized，其次还有 ReentrantLock、CAS、原子类等，不过我们先并不用关心每个锁的细节，这不是此文重点，这里只是为了讲解清楚锁是什么。

好了，回归正题，这里我们拿 synchronized 举例，重新看下改造完成的代码：

```java
public class Demo {

    // 同时在线人数
    private int onlineCount;

    public synchronized void login() {
        // 省略其他逻辑
        onlineCount ++;
    }

    // 获取同时在线人数
    public int getOnlineCount() {
        return onlineCount;
    }
}
```

可以发现和之前代码唯一的区别就是在 login 方法上加了个 synchronized，也就是加了把锁。这样就行了吗？

那肯定，一点问题没有。因为锁具有互斥性，虽然你`onlineCount ++;`分为了三步骤，**但是这三步骤同时只能被一个线程操作，已经具有原子性了**。也就是说当这三步没执行完的时候，其他线程无法得到执行，只能单线程执行，所以它是绝对安全的。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f8a467ca5b84e3abc03edc2afc580c9~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1602&h=866&s=137638&e=png&b=ffffff)

但是 synchronized/ReentrantLock/AtomicInteger 等原子类，保证的是什么级别的线程安全？是**单JVM级别**的！现在哪个项目不是集群部署？假如说上面不是计数器，而是秒杀系统扣减库存，库存总量 100 个，并发 1000 万个来抢，用 JVM 的锁保证的是什么？是每台机器不会超出 100 个。那比如 3 台机器各自保证了各自的线程安全，有用吗？A 机器保证自己不能卖出大于 100 个，但 B 和 C 机器也同样可能卖出去 100 个。那么整个集群内最后卖出去的数量极大概率是大于库存总量的，也就是说很大概率会出现超卖的情况。

问题出现在哪？问题出现在集群部署，然后我们的锁都是各自 JVM 的，自己管自己，你加锁了我看不到、我也不知道，我以为你没加锁呢，我就继续去表里减库存了，那这种集群下的锁怎么办？我们是不是可以把锁状态单独存到一个位置，集群内的机器都从那个地方去获取锁呢？这样大家的锁都是同一把，不是 JVM 级别的了，这样不就能保证全局线程安全了吗？没错！这就是分布式锁！

一言以蔽之：

* **锁能保证多线程环境对同一份资源竞争的数据安全性。**
* **分布式锁是** **用于保证整个集群内的多线程并发线程安全性的一种手段。**

在多线程并发的情况下，Java 的 synchronized/Reentrantlock 锁只能保证在同一个 JVM 进程内的多线程并发安全性。但是现在都是集群部署，也就是多个 JVM 实例，所以 Java 内置的锁无法保证集群环境的多线程安全性，只能保证自身 JVM 的。**如果在分布式的集群环境中，就需要使用分布式锁来保证整个集群的线程安全性**。

现在你肯定对什么是锁、什么是分布式锁以及为什么要用它都一清二楚了，那么又该如何实现一把分布式锁呢？要搞懂实现分布式锁的步骤和方法，我们需要先来了解下分布式锁的一些必备特征，这是分布式锁的敲门砖，搞清楚这些特征将非常有利于你更好地理解分布式锁设计的核心理念以及思想。

# 二、分布式锁必备特征

分布式锁主要有四个必备特征：高性能、可重入、防死锁和互斥性，下面我们就来一一说明。

第一个特征，**高性能**。这个比较好理解，分布式锁的性能很低的话，那会严重影响我们的主业务逻辑。比如我们设计一款秒杀系统，秒杀系统的关键是什么？是追求高 QPS 以及不能超卖，我们假设用分布式锁来防止超卖的情况，那即便我们的秒杀代码写得很 nice，性能达到了极致，但是每次上锁和解锁都花了几百毫秒，这能忍吗？肯定不能！所以分布式锁一定要高性能。

第二个特征，**可重入**。对 Java 的基础锁有了解的同学肯定一下就知道什么意思了，就是比如 A 线程对 test() 方法进行了上锁，test() 方法内部又调用了一个 abc() 方法，这个 abc() 方法也有锁，那会出现什么情况呢？死锁了！因为 test方法() 请求 abc() 方法的时候一直阻塞着，却又无法释放，伪代码如下：

```java
public synchronized void test() {
    // 阻塞卡死了
    abc();
}

public synchronized void abc() {}
```

所以这时候就需要可重入，**可重入的条件就是持有锁的线程是当前请求的线程。** 比如上面例子中，test() 方法和 abc() 方法是同步调用的，明显是一个线程，这时候就要可以正常请求，而不是阻塞等待卡死。需要注意的点就是：**重入几次就要释放几次。**

第三个特征，**防死锁**。上面刚讲解的，如果锁是不可重入的，那很可能就导致死锁了。还有一种情况就是客户端 1 加锁了，还没来得及释放，服务宕机了，那这把锁怎么释放？不释放的话其他客户端永远执行不了这个方法，当机器恢复后客户端 1 也无法执行，这也是一种死锁的表现，具体用什么手段去防止这种情况的发生，后面的篇幅会详细分析。

第四个特征，**互斥性**。互斥性用一句话来描述就是：**不允许多个客户端同时执行一段代码。** 比如，客户端 A 在执行 method1()，这时候客户端 B 进来了，也在执行 method1()，客户端 A 和客户端 B 同时执行，这就不具备互斥性。正常互斥的逻辑应该是客户端 A 执行 method1() 就相当于给大门上了一把锁，当其他客户端再来的时候发现大门是锁着的，没有钥匙，只能等待。只有当客户端 A 释放锁（打开大门后），其他客户端才能进去抢锁（钥匙）。

关于这四个核心特征我们已经知道其含义了，那该如何实现这四个特征呢？下面我们一个一个“攻破”。

先来看**高性能**，这个没什么好说的，举个最简单的例子：你把锁存在磁盘上，每次从磁盘上拿数据，那肯定性能较低；但是你把锁存到内存中，每次从内存中取数据，那肯定效率远大于磁盘的方式。我们使用分布式锁直接采取业界成熟的开源框架，比如 Redis 和 ZooKeeper，所以性能问题无须我们考虑，我们只需要知道分布式锁肯定要高性能，否则拖慢了业务系统的 rt 那不是浪费感情吗？

再来看**可重入和互斥性**。锁重入怎么设计？也很简单，为每个线程单独记录下重入次数，比如线程 1 重入 2 次，那就是`thread1:2`。核心逻辑就是：请求进来后判断有没有锁，没有锁就加锁，有锁就继续判断持有锁的线程是不是当前请求线程，是的话就是锁重入，直接给重入次数 +1 即可。那如果有锁，且持有锁的线程不是自己怎么办？那肯定**要互斥**的，直接调`wait()`方法阻塞等待即可。

最后看看如何**防死锁**。造成死锁的原因就是服务意外宕机导致锁永远得不到释放，那我们有办法保证服务 100% 不意外宕机吗？我们没办法保证！那就需要考虑宕机后该怎么自动释放锁了，我们可以给每把锁添加过期时间，这样假设服务意外宕机了，但是锁等待一段时间超时了就会自动释放了，避免了死锁的发生。

# 三、实现分布式锁的常用方式

到目前为止我们已经掌握了分布式锁的四个必备特征以及设计分布式锁的核心理念和设计思想，那么我们需要从 0 开始自己实现吗？肯定是不需要的，互联网分布式系统已经太成熟了，业界也早已经为我们提供了很多实现完成的开源框架，**目前最主流的是Redis和ZooKeeper**，当然 MySQL 也是可以实现的。下面我就来简单说明下我们小册对于这部分内容的设置情况。

1. **MySQL** 相对性能低下也并非安全，主要是基于 MySQL 的唯一索引在 insert 的时候会出现重复 key 的错误来实现。后面我会单独出一篇文章来讲解 MySQL 实现分布式锁的核心思想以及其伪代码实现。

2. **Redis** Redis 实现分布式锁的课程安排是这样的：先来讲解下 Redis 实现分布式锁的方式有哪些、各有什么优缺点，然后详细展开每一种实现方式的核心架构设计和核心源码剖析，最后做个 Redis 实现分布式锁的总结。

整体主要基于 Redisson 来讲解，如下种类我会一一剖析其核心架构和核心源码：

* 可重入锁（Reentrant Lock）
* 公平锁（Fair Lock）
* 联锁（MultiLock）
* 红锁（RedLock）
* 读写锁（ReadWriteLock）
* 信号量（Semaphore）
* 可过期的信号量（PermitExpirableSemaphore）
* 闭锁（CountDownLacth）

3. **ZooKeeper**

ZooKeeper 实现分布式锁的课程安排是这样的：先来讲解下如何用 ZooKeeper 设计一把分布式锁，这样你就可以直接掌握 ZooKeeper 设计分布式锁的核心原理以及其精髓之处，然后再基于 Curator 这个 ZooKeeper 工具包来讲解 ZooKeeper 实现分布式锁的一些方式，当然老规矩，我依然会剖析其底层核心架构以及核心源码。

整体来说，我们小册就是基于这样一个逻辑来设置的，应该还是比较好理解的。

# 四、常见的分布式锁应用场景

到这里，关于分布式锁，你可能还会问：“那分布式锁常见的应用场景有哪些呢？或者说在什么情况下会用到分布式锁呢？”对于这个问题，我做了以下几点总结和解释。

* **防止缓存击穿**。缓存击穿是什么？比如某购物平台创建了一个秒杀 iPhone 13 的活动，这时候流量肯定不能直接打到数据库，因为数据库扛不住，我们需要缓存起来，假设放到了 Redis，那如果 Redis 里 iPhone 13 这个 key 失效了，这时候秒杀的流量不就都打到数据库了吗？所以这时候可以在查数据库的时候加一个分布式锁，查出来后再把数据缓存到 Redis，这样就能保证大流量请求进来的时候，即便 Redis 失效了也只会有一个请求同时打到数据库中。这就是缓存击穿以及用分布式锁来解决缓存击穿的实现思路。

* **保证接口幂等性**。举个最简单的例子：表单重复提交，点击提交后还没处理完，又点击了一次提交按钮，这时候就相当于提交了两份。分布式锁也可以解决此场景，提交接口添加分布式锁，第一次提交的时候会锁住，然后第二次提交发现有锁，就不会执行业务逻辑了。

* **任务调度**。比如要写个定时器，定时统计数据发邮件，我们部署了五台机器，如果没用其他分布式调度框架的话，那岂不是五台机器都在执行定时任务，每天收到五封完全相同的邮件？其实，此场景也可以用分布式锁来保证集群部署的时候只有一台在工作，其他机器执行的时候发现有锁就不再执行了。

* **秒杀减库存等类似业务防止超卖的情况**（这个前面我们已经举过例子了，这里就不再赘述了）。

# 五、总结

学完本文后，你需要掌握如下知识点：

* 分布式锁是什么？有什么用？

* 分布式锁的核心必备东西有哪些？

* 设计一个分布式锁的常见方式有哪些？主流的有哪些？

* 分布式锁的应用场景有哪些？

在现在这个互联网时代，很多企业内的项目都是分布式的，分布式必然会涉及分布式锁的问题，如果没利用好分布式锁的话，那不仅不能解决我们所遇到的问题，还可能带来致命的死锁和性能问题。那怎么才能用好呢？

当然是掌握它的**核心设计思想和核心实现源码**，我们只有对分布式锁的核心实现原理和源码有一个深刻的理解，才能放心大胆地来使用它解决我们生产环境中的问题。之后的篇幅我们就会正式进入分布式锁的设计阶段。

# 六、拓展阅读

**Redisson**

源码地址：[github.com/redisson/re…](https://github.com/redisson/redisson "https://github.com/redisson/redisson")

中文文档：[github.com/redisson/re…](https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95 "https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95")

英文文档：[github.com/redisson/re…](https://github.com/redisson/redisson/wiki/Table-of-Content "https://github.com/redisson/redisson/wiki/Table-of-Content")

**Curator**

官方地址：[curator.apache.org/](https://curator.apache.org/ "https://curator.apache.org/")