上一篇我们讲解了如何利用Redis设计一个分布式公平，我们采取逐步推导的方式来完成最终的完整设计与核心源码。同样的，我们都知道JDK有个经典的锁设计，那就是读写锁，所以我们此篇会来剖析如何利用Redis设计一个分布式读写锁？我们依然采取逐步推导的方式，先一步步的梳理读写锁的核心特点与核心原理，然后最终落地到代码实现。先讲思想再讲实现，思想是最宝贵的东西！

在开始之前，先来看看什么是读写锁吧。

# 一、什么是读写锁？

想必大家都不陌生读写锁这三个字，因为JDK里也有读写锁，而且面试也常会问读写锁的设计原理。此处在稍微说一下读写锁的含义，读写锁就是字面意思，分为两种：**读锁和写锁，两种锁二合一称为读写锁。** 为什么要用读写锁？因为我们之前讲的锁都是互斥锁（不管是读还是写都互斥），互斥锁防止多线程修改同一条数据造成数据安全性问题。但是假设我们场景读多写少，我们想要的是读读操作其实不用互斥，因为读操作并不影响数据，无需互斥，只有写操作才需要互斥，这样才能性能最大化，这种实现方式如果采取之前讲的互斥锁的话，那么一个读请求就会加锁，其他读线程就无法继续持有锁了，那用互斥锁岂不是血亏，性能很拉垮嘛？所以有了**读写锁，读锁共享写锁互斥（也就是读读共享、读写互斥、写写互斥），所以正好适用于读多写少的场景。**

知道了读写锁是什么意思后，那就正式开始分析我们该如何利用Redis实现一把分布式的读写锁呢？

# 二、读写锁的核心原理

在设计之前我们先来看下读写锁具备哪些特点？

**首先我们已经知道读写锁其实就是两种锁，读锁和写锁。其次其核心特点为：读读共享、读写互斥、写写互斥**。那这三个特点什么意思呢？下面逐个举例说明含义。

**读读共享：** 也就是读锁和读锁之间不互斥，比如A和B两个请求都加了读锁，那么他们是可以同时运行的，不会互斥阻塞的，因为读请求并不会影响数据，所以无需互斥，这就是读读共享的含义。

**读写互斥：** 也就是读锁和写锁之间互斥，比如A和B两个请求，A请求加了读锁，B请求加了写锁，那么A进来抢占到读锁后，在A释放读锁之前，B是无法加写锁的，会阻塞，这就是读写互斥。同理，如果B先加了写锁，A再去加读锁的话也一样会阻塞。

**写写互斥：** 和读写互斥是一个道理，两个写锁之间是互斥的，很好理解。

说了这么多其实本质就两种锁：读锁和写锁。至于是共享还是互斥，那都是这两种锁组合起来的特点，所以我们需要看看读锁和写锁该如何实现才能满足这些特点，先从写锁说起，看下写锁加锁流程我们该如何设计。

## 1\. 写锁如何加锁？

首先我们温习下写锁的特点：**读写互斥、写写互斥。** 这跟我们之前几篇讲解的锁有啥区别？没任何区别。就是一个普通的互斥锁，我们经过前面几篇文章已经掌握了锁的结构：hash结构。比如key叫readWriteLock，那么就是如下：

```bash
"readWriteLock": {
    # uuid:threadId就是代表当前线程，之前都讲过。
    # 1是可重入次数，之前都讲过。
    "uuid:threadId": 1
}
```

但是是不是缺点东西？我怎么知道它是读锁还是写锁呢？这时候就需要引入一个字段来标记是读锁还是写锁，我们把这个字段叫：**mode（取值read/write）** ，所以变成了如下：

```arduino
"readWriteLock": {
    "mode": write,
    "uuid:threadId": 1
}
```

所以写锁的加锁原理讲完了，你没看错，就是这么简单，就是普普通通的一把可重入的互斥锁。那接下来我们再看看读锁如何加锁呢？

## 2\. 读锁如何加锁？

老规矩，首先我们温习下读锁的特点：**读读共享。** 你想想，是不是也很简单？首先我们锁是hash结构，然后每个元素是具体的锁，那我们支持共享锁的话直接在hash结构里追加不同的`uuid:threadId`不就好了嘛，`uuid:threadId`一样的话肯定是锁重入的情况。不一样的话肯定就是读读共享的场景直接追加到hash结构里，比如如下：

```arduino
"readWriteLock": {
    "mode": read,
    "uuid:threadId1": 2,
    "uuid:threadId2": 1
}
```

上面这段就代表：

* `uuid:threadId1`持有锁，且重入了1次（加锁1次，重入1次。值是2）。
* `uuid:threadId2`也持有锁。

这就是共享锁加锁的核心设计，很简单。

现在读锁和写锁的加锁核心原理我们都剖析完了，那他们组合起来后是怎么实现**读读共享、读写互斥、写写互斥**这三个特点的？也很简单，我们逐个分析下：

**读读共享：** 我们有了mode这个字段，它代表锁的类型，那我们判断当前锁是不是读锁（mode=read），如果是读锁，那就是可共享的，如果再有读锁进来的话直接在hash里新增就完事了。这就是读读共享。

![读读共享.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df6a4ea7c9124f7aa2820b65f63820dd~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1002&h=608&s=73868&e=png&b=59ff53)

**读写互斥/写写互斥：** 如果当前锁是写锁（mode=write），那就是互斥的，除了自己加锁（因为自己加锁是可以锁重入的嘛），后面不管是读锁还是写锁都不让添加，一律阻塞等待，这就是读写互斥和写写互斥。同理，换个顺序，如果当前锁是读锁（mode=read），那么现在来个写锁请求，那自然也是排队等待，因为读写互斥。

![读写互斥-写写互斥.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cacf1ddf2a01486fb5e65b3d161a3086~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1564&h=696&s=119858&e=png&b=59ff53)

**一言以蔽之：有了锁类型（mode），那直接根据当前锁的类型是读锁还是写锁来控制是否可以共享即可。**

现在加锁的全部原理都已经剖析完成，但是我们知道锁有个watchDog看门狗的功能，那么读写锁的watchDog该如何实现？

## 3\. watchDog怎么工作？

依然要区分两种锁形式：读锁和写锁，我们先从写锁看起。

**写锁**

太简单了，跟之前是一样的，没啥区别。假设key是readWriteLock，那就直接给这个key续期就行了。**因为是互斥的。** 之前文章剖析过watchDog，一模一样的，不再重复。

那读锁的watchDog该如何实现呢？

**读锁**

读锁怎么续期呀？就一个hash结构，这个hash结构下面多个读锁，每个读锁的过期时间都不一样，那不能续期的时候直接给hash结构续期呀，这样的话就相当于给全部锁续期了。比如：

```arduino
"readWriteLock": {
    "mode": read,
    "aaa": 2,
    "bbb": 1
}
```

`aaa`和`bbb`是两把单独的锁，watchDog续期肯定是分开的，两个独立的续期功能。肯定不能只直接给`readWriteLock`这个最外层的hash直接续期，因为如果直接给最外层hash续期的话，那多个读锁共享的话，假设他们的过期时间不一样，就出问题了，因为他们都在hash里，要么全过期，要么全不过期了。那怎么做才能给每一把读锁单独续期？

可以在搞个timeoutKey单独记录每个线程的过期时间，然后续期的时候不仅续期`readWriteLock`还续期这个单独的timeoutKey，比如这个timeoutKey叫：`{readWriteLock}:threadId:rwlock_timeout`，那伪代码就是：

```ruby
# 给hash结构续期
pexpire readWriteLock 30000
# 给单独读锁续期
pexpire {readWriteLock}:aaa:rwlock_timeout 30000
```

**一言以蔽之：写锁和读锁的watchDog区别在于读锁需要为每把锁单独创建一个timeoutKey来维护锁过期时间，原因就在于他是读读共享。**

加锁和watchDog的核心原理都分析完了，接下来还有一个问题，锁怎么释放呢？这又分为两种情况：读锁释放和写锁释放。先来看看读锁怎么释放。

## 4\. 读锁怎么释放？

是直接删除hash结构吗？肯定不是，因为读读共享，hash里不仅有自己当前锁还有其他线程加的读锁，那直接把自己的锁从hash结构里移除不就行了？也不行，因为有锁重入的情况呀，所以首先需要考虑两种情况：重入、非重入。

1. 如果是非重入的话那就太简单了，直接从hash里del掉自己的锁和删除timeoutKey（读锁单独维护的过期时间的key）就行了。

2. 如果是重入的话那就只给锁重入次数-1，不删除锁。

最后判断一下hash里的锁是不是大于1个，不是的话就代表无锁了，直接`del hashkey`就完事了。

大家看到这里可能有个小疑问，为啥是大于1而不是大于0？别忘了，我们hash里不仅有锁，还有mode(read/write)，这也是hash的一个子元素，所以这里判断大于1而不是大于0，比如如下情况就是无锁了，因为不大于1个。只有1个，那就是mode：

```arduino
"readWriteLock": {
    "mode": read
}
```

接下来再看看写锁如何释放？

## 5\. 写锁怎么释放？

和读锁一样的原理，需要考虑两种情况：重入、非重入。但是写锁就太简单了，因为是互斥的，所以没有timeoutKey这个东西，同时只能加一把锁，所以写锁释放与读锁释放的核心区别在于读锁有一个单独的timeoutKey来维护每把读锁的过期时间，所以也需要删除这个timeoutKey，而写锁没这东西，释放的时候直接处理hash结构就行。

# 三、总结

此篇文章内容很干，涵盖了Redis实现分布式读写锁的全部核心原理，从加锁到解锁，以及每种锁组合起来的特点和实现思路都剖析的很透彻了。我们可以稍微总结一下：

1. 我们先介绍了什么是读写锁，分为两种：读锁和写锁，二者合一称之为读写锁。也就是说可以用读写锁这个类获取到读锁和写锁两种锁类型。
2. 我们还介绍了读锁和写锁的加锁/解锁原理以及watchDog是如何工作的。
3. 我们最后也介绍了读锁和写锁这两个锁组合起来的一些特点：读读共享、读写互斥、写写互斥，以及每种特点的实现原理。

这篇以思想和设计原理为主，下一篇我们就会分析下Redisson这个框架是如何利用Redis来实现分布式读写锁的？到时候对照着我们本篇的核心设计思想去看Redisson实现分布式读写锁核心源码的时候就会变的很简单。