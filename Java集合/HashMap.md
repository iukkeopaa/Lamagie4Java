## HashMap为什么底层用数组和链表，而不是用数组和数组的形式


## 1. **解决哈希冲突**

`HashMap` 的核心思想是通过哈希函数将键（key）映射到数组的索引位置。然而，哈希函数可能会产生冲突，即不同的键映射到相同的数组索引。为了解决冲突，`HashMap` 使用了链表（或红黑树）来存储冲突的键值对。

- **数组 + 链表**：当发生哈希冲突时，冲突的键值对会被存储在同一个数组索引位置的链表中。
- **数组 + 数组**：如果使用数组来存储冲突的键值对，会导致以下问题：
    - 需要预先分配固定大小的数组，浪费内存。
    - 如果冲突较多，数组会变得非常大，影响性能。
    - 动态扩容和缩容的复杂度较高。

链表可以动态地扩展和收缩，适合处理不确定数量的冲突。

------

## 2. **内存效率**

- **数组 + 链表**：链表只在发生冲突时才会创建，内存使用更加高效。未发生冲突的数组位置只需要存储一个链表头节点（或 `null`）。
- **数组 + 数组**：即使没有冲突，也需要为每个数组位置分配一个子数组，浪费内存。

------

## 3. **性能优化**

- **链表**：在冲突较少的情况下，链表的插入和删除操作的时间复杂度是 O(1)。
- **红黑树**：当链表长度超过一定阈值（默认是 8）时，`HashMap` 会将链表转换为红黑树，将查找、插入和删除的时间复杂度从 O(n) 优化为 O(log n)。
- **数组 + 数组**：如果使用数组来存储冲突的键值对，查找、插入和删除的时间复杂度会更高，因为需要遍历整个子数组。

------

## 4. **动态扩容**

`HashMap` 的底层数组会根据负载因子（load factor）动态扩容。链表和红黑树的结构可以很好地适应这种动态变化：

- 链表可以动态增长和缩减。
- 红黑树可以在链表过长时自动转换，保证性能。

如果使用数组来存储冲突的键值对，动态扩容的复杂度会更高，因为需要重新分配和复制子数组。

------

## 5. **实现简单**

- **链表**：链表的实现简单，插入和删除操作只需要修改指针。
- **数组 + 数组**：实现复杂，需要处理子数组的动态扩容和缩容，增加了代码的复杂性。

------

## 6. **哈希冲突的概率**

在实际应用中，哈希冲突的概率通常较低。大多数情况下，一个数组位置只会存储一个键值对，链表或红黑树的结构可以很好地处理少数冲突的情况。如果使用数组来存储冲突的键值对，会导致内存浪费和性能下降。

------

## 总结

`HashMap` 使用数组和链表（或红黑树）的组合，而不是数组和数组的形式，主要是为了解决哈希冲突、提高内存效率、优化性能、支持动态扩容以及简化实现。链表和红黑树的结构可以很好地适应 `HashMap` 的需求，使其在大多数场景下都能高效地工作。