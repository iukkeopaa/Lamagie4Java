### `Collection` 体系

#### `List` 接口



`List` 接口表示有序、可重复的集合，常见的实现类有 `ArrayList`、`LinkedList` 和 `Vector`。



- `ArrayList`
    - **底层数据结构**：动态数组。它使用一个数组来存储元素，当数组容量不足时，会自动进行扩容操作。
    - **特点**：随机访问速度快，时间复杂度为 \(O(1)\)；插入和删除操作在数组末尾进行时效率较高，时间复杂度为 \(O(1)\)，但在中间或开头进行插入和删除操作时，需要移动大量元素，时间复杂度为 \(O(n)\)。
- `LinkedList`
    - **底层数据结构**：双向链表。每个节点包含数据、指向前一个节点的引用和指向后一个节点的引用。
    - **特点**：插入和删除操作效率高，时间复杂度为 \(O(1)\)，因为只需要修改节点的引用；随机访问速度慢，时间复杂度为 \(O(n)\)，需要从头或尾开始遍历链表。
- `Vector`
    - **底层数据结构**：动态数组，与 `ArrayList` 类似。
    - **特点**：线程安全，但由于使用了同步机制，性能相对较低。扩容时，`Vector` 可以指定扩容因子，默认扩容为原来的 2 倍。

#### `Set` 接口



`Set` 接口表示无序、不可重复的集合，常见的实现类有 `HashSet`、`LinkedHashSet` 和 `TreeSet`。



- `HashSet`
    - **底层数据结构**：哈希表（基于 `HashMap` 实现）。它使用哈希函数将元素映射到哈希表的某个位置进行存储。
    - **特点**：插入、删除和查找操作的平均时间复杂度为 \(O(1)\)；不保证元素的顺序。
- `LinkedHashSet`
    - **底层数据结构**：哈希表和双向链表。它继承自 `HashSet`，并使用双向链表维护元素的插入顺序。
    - **特点**：插入、删除和查找操作的平均时间复杂度为 \(O(1)\)；保证元素的插入顺序。
- `TreeSet`
    - **底层数据结构**：红黑树（自平衡的二叉搜索树）。它会根据元素的自然顺序或指定的比较器对元素进行排序。
    - **特点**：插入、删除和查找操作的时间复杂度为 \(O(log n)\)；保证元素按照排序顺序存储。

### `Map` 体系



`Map` 接口表示键值对的集合，常见的实现类有 `HashMap`、`LinkedHashMap`、`TreeMap` 和 `Hashtable`。



- `HashMap`
    - **底层数据结构**：哈希表（数组 + 链表 + 红黑树）。在 JDK 8 之前，`HashMap` 是数组 + 链表的结构；JDK 8 及以后，当链表长度超过 8 且数组长度大于 64 时，链表会转换为红黑树，以提高查找效率。
    - **特点**：插入、删除和查找操作的平均时间复杂度为 \(O(1)\)；不保证键的顺序。
- `LinkedHashMap`
    - **底层数据结构**：哈希表和双向链表。它继承自 `HashMap`，并使用双向链表维护键值对的插入顺序或访问顺序。
    - **特点**：插入、删除和查找操作的平均时间复杂度为 \(O(1)\)；可以保证键值对的插入顺序或访问顺序。
- `TreeMap`
    - **底层数据结构**：红黑树。它会根据键的自然顺序或指定的比较器对键进行排序。
    - **特点**：插入、删除和查找操作的时间复杂度为 \(O(log n)\)；保证键按照排序顺序存储。
- `Hashtable`
    - **底层数据结构**：哈希表。它是线程安全的，与 `HashMap` 类似，但使用了同步机制，性能相对较低。
    - **特点**：不允许键或值为 `null`；插入、删除和查找操作的平均时间复杂度为 \(O(1)\)。



综上所述，不同的集合类基于不同的底层数据结构实现，各自具有不同的特点和适用场景。开发者可以根据具体的需求选择合适的集合类。


## 总结2

### **1. List（有序、可重复）**

#### **(1) `ArrayList`**

- **底层数据结构**：动态数组。
- **特点**：
    - 查询快（通过索引直接访问）。
    - 增删慢（需要移动元素）。
    - 线程不安全。
- **扩容机制**：
    - 默认初始容量为 10。
    - 扩容时，新容量为原容量的 1.5 倍。

#### **(2) `LinkedList`**

- **底层数据结构**：双向链表。
- **特点**：
    - 增删快（只需修改指针）。
    - 查询慢（需要遍历链表）。
    - 线程不安全。

#### **(3) `Vector`**

- **底层数据结构**：动态数组。
- **特点**：
    - 线程安全（方法使用 `synchronized` 修饰）。
    - 性能较低（由于同步开销）。
- **扩容机制**：
    - 默认初始容量为 10。
    - 扩容时，新容量为原容量的 2 倍。

------

### **2. Set（无序、不可重复）**

#### **(1) `HashSet`**

- **底层数据结构**：基于 `HashMap` 实现。
- **特点**：
    - 元素无序。
    - 查询、插入、删除速度快（平均时间复杂度为 O(1)）。
    - 线程不安全。

#### **(2) `LinkedHashSet`**

- **底层数据结构**：基于 `LinkedHashMap` 实现。
- **特点**：
    - 元素按插入顺序排序。
    - 查询、插入、删除速度快。
    - 线程不安全。

#### **(3) `TreeSet`**

- **底层数据结构**：基于红黑树（自平衡二叉搜索树）。
- **特点**：
    - 元素按自然顺序或自定义顺序排序。
    - 查询、插入、删除时间复杂度为 O(log n)。
    - 线程不安全。

------

### **3. Map（键值对）**

#### **(1) `HashMap`**

- **底层数据结构**：数组 + 链表 + 红黑树（JDK 8+）。
- **特点**：
    - 键值对无序。
    - 查询、插入、删除速度快（平均时间复杂度为 O(1)）。
    - 线程不安全。
- **扩容机制**：
    - 默认初始容量为 16，负载因子为 0.75。
    - 当链表长度超过 8 时，链表转换为红黑树。

#### **(2) `LinkedHashMap`**

- **底层数据结构**：基于 `HashMap` + 双向链表。
- **特点**：
    - 键值对按插入顺序或访问顺序排序。
    - 查询、插入、删除速度快。
    - 线程不安全。

#### **(3) `TreeMap`**

- **底层数据结构**：红黑树。
- **特点**：
    - 键值对按自然顺序或自定义顺序排序。
    - 查询、插入、删除时间复杂度为 O(log n)。
    - 线程不安全。

#### **(4) `Hashtable`**

- **底层数据结构**：数组 + 链表。
- **特点**：
    - 键值对无序。
    - 线程安全（方法使用 `synchronized` 修饰）。
    - 性能较低（由于同步开销）。

------

### **4. Queue（队列）**

#### **(1) `LinkedList`**

- **底层数据结构**：双向链表。
- **特点**：
    - 可用作队列或双端队列。
    - 线程不安全。

#### **(2) `PriorityQueue`**

- **底层数据结构**：二叉堆（最小堆或最大堆）。
- **特点**：
    - 元素按优先级排序。
    - 插入、删除时间复杂度为 O(log n)。
    - 线程不安全。

#### **(3) `ArrayDeque`**

- **底层数据结构**：动态数组。
- **特点**：
    - 可用作栈或双端队列。
    - 查询、插入、删除速度快。
    - 线程不安全。

------

### **5. 线程安全的集合**

#### **(1) `Vector`**

- **底层数据结构**：动态数组。
- **特点**：
    - 线程安全（方法使用 `synchronized` 修饰）。
    - 性能较低。

#### **(2) `Hashtable`**

- **底层数据结构**：数组 + 链表。
- **特点**：
    - 线程安全（方法使用 `synchronized` 修饰）。
    - 性能较低。

#### **(3) `Collections.synchronizedXXX`**

- **特点**：
    - 通过工具类 `Collections` 提供的同步方法（如 `synchronizedList`、`synchronizedSet`）将普通集合转换为线程安全的集合。
    - 性能较低。

#### **(4) `ConcurrentHashMap`**

- **底层数据结构**：数组 + 链表 + 红黑树（JDK 8+）。
- **特点**：
    - 线程安全（使用分段锁或 CAS 机制）。
    - 性能较高。

#### **(5) `CopyOnWriteArrayList`**

- **底层数据结构**：动态数组。
- **特点**：
    - 线程安全（写时复制）。
    - 适合读多写少的场景。

#### **(6) `CopyOnWriteArraySet`**

- **底层数据结构**：基于 `CopyOnWriteArrayList` 实现。
- **特点**：
    - 线程安全（写时复制）。
    - 适合读多写少的场景。

------

### **6. 总结**

| **集合类**          | **底层数据结构**          | **特点**                   |
| :------------------ | :------------------------ | :------------------------- |
| `ArrayList`         | 动态数组                  | 查询快，增删慢             |
| `LinkedList`        | 双向链表                  | 增删快，查询慢             |
| `HashSet`           | 基于 `HashMap`            | 无序，查询、插入、删除快   |
| `LinkedHashSet`     | 基于 `LinkedHashMap`      | 按插入顺序排序             |
| `TreeSet`           | 红黑树                    | 按自然顺序或自定义顺序排序 |
| `HashMap`           | 数组 + 链表 + 红黑树      | 无序，查询、插入、删除快   |
| `LinkedHashMap`     | 基于 `HashMap` + 双向链表 | 按插入顺序或访问顺序排序   |
| `TreeMap`           | 红黑树                    | 按自然顺序或自定义顺序排序 |
| `Hashtable`         | 数组 + 链表               | 线程安全，性能较低         |
| `ConcurrentHashMap` | 数组 + 链表 + 红黑树      | 线程安全，性能较高         |
| `PriorityQueue`     | 二叉堆                    | 按优先级排序               |

通过了解集合类的底层数据结构，可以更好地选择适合场景的集合类，并优化程序性能。