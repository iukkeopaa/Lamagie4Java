## Sychronized的偏向锁、轻量级锁、重量级锁
1. 偏向锁:在锁对象的对象头中记录一下当前获取到该锁的线程ID，该线程下次如果又来获取该锁就可以直接
获取到了
2. 轻量级锁:由偏向锁升级而来，当一个线程获取到锁后，此时这把锁是偏向锁，此时如果有第二个线程来竞争
锁，偏向锁就会升级为轻量级锁，之所以叫轻量级锁，是为了和重量级锁区分开来，轻量级锁底层是通过自旋
来实现的，并不会阻塞线程
3. 如果自旋次数过多仍然没有获取到锁，则会升级为重量级锁，重量级锁会导致线程阻塞
4. 自旋锁:自旋锁就是线程在获取锁的过程中，不会去阻塞线程，也就无所谓唤醒线程，阻塞和唤醒这两个步骤
都是需要操作系统去进行的，比较消耗时间，自旋锁是线程通过CAS获取预期的一个标记，如果没有获取到，
则继续循环获取，如果获取到了则表示获取到了锁，这个过程线程一直在运行中，相对而言没有使用太多的操
作系统资源，比较轻量。


## 当一个线程进入一个对象的一个 synchronized 方法后，其它线程是否可进入此对象的其它方法?

分几种情况：

1. 其他方法前是否加了 synchronized 关键字，如果没加，则能。
2. 如果这个方法内部调用了 wait，则可以进入其他 synchronized 方法。
3. 如果其他个方法都加了 synchronized 关键字，并且内部没有调用 wait，则不能。
4. 如果其他方法是 static，它用的同步锁是当前类的字节码，与非静态的方法不能同
   步，因为非静态的方法用的是 this。

