## fork之后的内存分配


在使用 `fork()` 系统调用创建新进程时，涉及到父进程和子进程的内存分配情况，下面从不同操作系统实现机制的角度进行详细介绍。

### 传统的复制机制



在早期的操作系统实现中，`fork()` 会将父进程的整个地址空间（包括代码段、数据段、堆、栈等）完整地复制一份给子进程。也就是说，子进程会拥有一份与父进程几乎完全相同的内存副本。

#### 优点



- **简单直接**：实现逻辑较为简单，父进程和子进程的内存空间相互独立，一个进程对内存的修改不会影响到另一个进程。

#### 缺点



- **内存开销大**：复制整个地址空间会消耗大量的内存资源，尤其是当父进程占用的内存空间较大时，会导致系统内存使用量急剧增加。
- **复制时间长**：复制操作需要花费一定的时间，这会导致 `fork()` 系统调用的执行时间变长，影响系统的性能。

### 写时复制（Copy - On - Write，COW）机制



现代操作系统大多采用写时复制机制来优化 `fork()` 的内存分配。写时复制是一种延迟复制技术，它避免了在 `fork()` 时立即复制父进程的整个地址空间，而是让父进程和子进程暂时共享相同的物理内存页。

#### 工作原理



1. **`fork()` 调用时**：当调用 `fork()` 时，操作系统并不立即复制父进程的内存页，而是为子进程创建一个新的虚拟地址空间，并将父进程的页表项复制给子进程，使得父进程和子进程的虚拟地址空间都指向相同的物理内存页。同时，将这些物理内存页标记为只读。
2. **内存写入操作时**：当父进程或子进程尝试对共享的物理内存页进行写入操作时，操作系统会检测到该页是只读的，此时会触发一个页错误（Page Fault）。操作系统会为执行写入操作的进程分配一块新的物理内存页，并将原来的内容复制到新的内存页中，然后将该进程的页表项更新为指向新的物理内存页，同时将新的内存页标记为可写。这样，父进程和子进程就各自拥有了独立的内存副本。

#### 优点



- **减少内存开销**：在 `fork()` 时不需要立即复制整个地址空间，只有在真正需要写入时才进行复制，从而减少了内存的使用量。
- **提高性能**：避免了不必要的内存复制操作，减少了 `fork()` 系统调用的执行时间，提高了系统的性能。

#### 示例代码（C 语言）












```c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main() {
    pid_t pid;
    int shared_variable = 10;

    pid = fork();

    if (pid < 0) {
        perror("Fork failed");
        return 1;
    } else if (pid == 0) {
        // 子进程
        printf("Child process: shared_variable = %d\n", shared_variable);
        shared_variable = 20;
        printf("Child process: shared_variable is now %d\n", shared_variable);
    } else {
        // 父进程
        printf("Parent process: shared_variable = %d\n", shared_variable);
        sleep(1); // 等待子进程修改共享变量
        printf("Parent process: shared_variable is still %d\n", shared_variable);
    }

    return 0;
}
```







在这个示例中，父进程和子进程在 `fork()` 之后共享 `shared_variable` 的初始值。当子进程修改 `shared_variable` 时，由于写时复制机制，子进程会获得一个独立的内存副本，而父进程的 `shared_variable` 值不会受到影响。

### 内存映射区域



除了上述的代码段、数据段、堆和栈，`fork()` 还会影响内存映射区域（如使用 `mmap()` 系统调用创建的映射）。



- **私有映射**：对于私有映射（如 `MAP_PRIVATE` 标志创建的映射），`fork()` 之后父进程和子进程会各自拥有独立的映射副本。在写时复制机制下，它们最初共享相同的物理内存页，直到有一方进行写入操作时才会复制。
- **共享映射**：对于共享映射（如 `MAP_SHARED` 标志创建的映射），`fork()` 之后父进程和子进程会继续共享同一个映射，对该映射区域的修改会在父进程和子进程之间可见。