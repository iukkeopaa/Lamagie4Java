## ReentrantLock中的公平锁和非公平锁的底层实现

ReentrantLock是Java中提供的一种可重入锁，它支持两种锁的模式:公平锁和非公平锁。这两种锁模式的底层实 自
现略有不同:
1. 公平锁(Fair Lock): 公平锁的特点是按照请求锁的顺序来分配锁，即先到先得。在ReentrantLock中，通
过构造函数可以选择创建一个公平锁。公平锁的底层实现使用了一个FIFO队列(First-In-first-Out)，即等
待队列。当一个线程请求锁时，如果锁已经被其他线程持有，请求线程会被放入等待队列的未尾，按照请求的
顺序等待锁的释放。当锁被释放时，等待队列中的第一个线程会被唤醒并获得锁。
2. 非公平锁Non-Fair Lock): 非公平锁不考虑请求锁的顺序，它允许新的请求线程插队并尝试立即获取
锁，而不管其他线程是否在等待。在ReentrantLock中，默认情况下创建的是非公平锁。非公平锁的底层实现
中，有一个等待队列，但它不会严格按照请求的顺序来分配锁，而是根据线程竞争锁的情况来判断是否立即分
配给新的请求线程。

底层实现中，无论是公平锁还是非公平锁，都使用了类似的同步器(Sync)来管理锁的状态和线程的竞争。不同
之处在于如何处理等待队列中的线程，以及是否按照请求的顺序来分配锁。

需要注意的是，公平锁虽然遵循公平性原则，但在高并发情况下可能会引入较大的性能开销，因为每次都要维护-
个有序的等待队列。而非公平锁则更加灵活，但可能导致某些线程一直获取不到锁。

## 锁的优化机制了解吗

是的，锁的优化机制是Java等编程语言中常见的一种提高并发性能的方法。锁的优化旨在减少锁的竞争，从而提高
程序的性能。以下是一些常见的锁优化机制:
1. 偏向锁(Biased Locking):偏向锁是一种针对无竞争情况的锁优化机制。它通过消除无谓的获取锁和释放
锁的操作，提高了程序的性能。偏向锁会记录哪个线程正在访问某个对象，并且后续的访问请求如果是同一个
线程，就可以直接访问，而不需要加锁。
2. 轻量级锁(Lightweight Locking):轻量级锁是一种针对单线程访问的情况的锁优化机制。它通过使用标记
位或者CAS操作来对共享资源进行加锁和解锁，避免了使用重量级锁时的上下文切换和内核态切换等开销。
3. 自旋锁(Spin Lock):自旋锁是一种非阻塞的锁机制，当线程无法立即获取锁时，它会持续检查锁是否被释
放，直到获取到锁为止。自旋锁可以减少线程的上下文切换开销，但在锁持有时间较长的情况下，会浪费
CPU资源。
4. 适应性自旋锁(Adaptive Spin Lock):适应性自旋锁是一种结合了自旋锁和阻塞锁的锁机制。在刚开始
时，线程会采用自旋的方式来等待锁的释放，但随着时间的推移，如果锁仍然没有被释放，线程会逐渐切换到
阻塞状态，从而减少CPU资源的浪费
5. 分段锁(Segmented Locking):分段锁是一种针对共享资源过多的情况下的锁优化机制。
，它将共享资源分成多个段，每个线程只需要对其中一部分进行加锁和解锁操作，从而减少了锁的竞争和开销。
6. 乐观锁(Optimistic Locking):乐观锁是一种基于冲突检测的锁机制。它假设多个线程同时访问和修改同-
个数据的概率较小，因此在读取数据时不会加锁，而是在提交修改时检测是否存在冲突。如果存在冲突，则进
行回滚或重试操作。乐观锁适用于读操作较多的场景。
7. 锁粗化(Lock Coarsening):锁粗化是一种针对长时间持有锁的场景的优化策略。如果一个线程在短时间内
需要连续多次加锁和解锁，那么可以将这些加锁和解锁操作合并成一个较大的加锁和解锁操作，从而减少了加
锁和解锁的次数，提高了效率，

这些锁的优化机制都有各自的适用场景和优缺点，需要根据具体的业务需求和性能要求来选择合适的锁机制。

## 对象锁和方法锁的区别

在 Java 里，对象锁和方法锁本质上都属于同步机制，其核心作用是保证同一时刻只有一个线程能够访问被锁定的代码块或方法，以此来避免多线程并发访问时可能出现的数据不一致问题。不过，它们在底层实现上存在一些差异，下面详细介绍。

### 基础概念



- **对象锁**：指的是对某个对象实例进行加锁，通常使用 `synchronized` 代码块的形式来实现。例如：











```java
public class ObjectLockExample {
    private final Object lock = new Object();

    public void doSomething() {
        synchronized (lock) {
            // 同步代码块，同一时刻只有一个线程能进入
        }
    }
}
```



- **方法锁**：指的是对某个方法进行加锁，使用 `synchronized` 修饰方法。例如：









```java
public class MethodLockExample {
    public synchronized void doSomething() {
        // 同步方法，同一时刻只有一个线程能调用
    }
}
```

### 底层实现差异

#### 1. 锁的对象



- **对象锁**：锁的对象是开发者指定的对象实例。就像上述示例中的 `lock` 对象，线程在进入 `synchronized` 代码块之前，必须先获取 `lock` 对象的锁。

- 方法锁

  ：

    - 对于实例方法，锁的对象是当前对象实例（即 `this`）。例如在 `MethodLockExample` 类中，当线程调用 `doSomething` 方法时，需要获取当前 `MethodLockExample` 对象的锁。
    - 对于静态方法，锁的对象是该类的 `Class` 对象。例如：









```java
public class StaticMethodLockExample {
    public static synchronized void doSomething() {
        // 静态同步方法，同一时刻只有一个线程能调用
    }
}
```



这里线程在调用 `doSomething` 方法时，需要获取 `StaticMethodLockExample.class` 对象的锁。

#### 2. 字节码层面



- **对象锁**：在字节码中，`synchronized` 代码块是通过 `monitorenter` 和 `monitorexit` 指令来实现的。`monitorenter` 指令用于获取对象的监视器（锁），`monitorexit` 指令用于释放对象的监视器。例如：










```java
public class ObjectLockBytecodeExample {
    private final Object lock = new Object();

    public void doSomething() {
        synchronized (lock) {
            // 同步代码块
        }
    }
}
```



对应的字节码片段可能如下（简化示意）：












```plaintext
monitorenter
// 同步代码块中的指令
monitorexit
```



- **方法锁**：对于同步方法，在字节码中并没有显式的 `monitorenter` 和 `monitorexit` 指令，而是通过方法的访问标志 `ACC_SYNCHRONIZED` 来标识。当线程调用带有 `ACC_SYNCHRONIZED` 标志的方法时，Java 虚拟机（JVM）会自动获取该方法所属对象的锁，并在方法执行完毕后释放锁。例如：






```java
public class MethodLockBytecodeExample {
    public synchronized void doSomething() {
        // 同步方法
    }
}
```







其字节码中方法的访问标志会包含 `ACC_SYNCHRONIZED`。

#### 3. 锁的范围



- **对象锁**：锁的范围由 `synchronized` 代码块的边界决定，开发者可以灵活控制需要同步的代码范围，只对关键代码进行加锁，从而减少锁的粒度，提高并发性能。
- **方法锁**：锁的范围是整个方法体，一旦线程进入该方法，就会获取锁，直到方法执行完毕才会释放锁。这种方式可能会导致锁的粒度较大，影响并发性能。

### 总结



对象锁和方法锁虽然都是基于对象的监视器（锁）机制实现的，但在锁的对象、字节码实现和锁的范围等方面存在差异。开发者可以根据具体的业务需求和性能要求，选择合适的同步方式。


## wait的底层

在 Java 中，`Object` 类的 `wait()` 方法是用于线程间通信的重要方法，它允许线程在某个对象上等待，直到其他线程调用该对象的 `notify()` 或 `notifyAll()` 方法来唤醒它。下面从原理、实现机制以及底层相关知识来详细介绍 `wait()` 方法的实现。

### 原理概述



`wait()` 方法的核心原理是基于 Java 的内置锁（监视器锁）和线程的状态管理。当一个线程调用对象的 `wait()` 方法时，它会释放该对象的监视器锁，进入等待状态（WAITING 或 TIMED_WAITING，取决于调用的是 `wait()` 还是 `wait(long timeout)`），直到其他线程调用该对象的 `notify()` 或 `notifyAll()` 方法，或者等待超时。

### 实现机制

#### 1. 监视器锁



在 Java 中，每个对象都有一个与之关联的监视器锁。当线程进入一个同步代码块或方法时，它会尝试获取该对象的监视器锁。一旦获取到锁，线程就可以执行同步代码块中的代码；当线程执行完毕或调用 `wait()` 方法时，会释放该锁。

#### 2. 等待集合



每个对象除了有一个监视器锁之外，还有一个等待集合（Wait Set）。当线程调用对象的 `wait()` 方法时，它会被放入该对象的等待集合中，并且释放监视器锁。等待集合是一个线程的队列，用于存储在该对象上等待的所有线程。

#### 3. `notify()` 和 `notifyAll()` 方法



- `notify()` 方法：会从对象的等待集合中随机选择一个线程，将其从等待集合中移除，并使其进入可运行状态，但该线程不会立即获得监视器锁，需要等待当前持有锁的线程释放锁。
- `notifyAll()` 方法：会将对象等待集合中的所有线程都移除，并使它们进入可运行状态，同样需要等待当前持有锁的线程释放锁。

### 底层实现（HotSpot JVM）

#### 1. 基于操作系统的线程同步机制



在 HotSpot JVM 中，`wait()`、`notify()` 和 `notifyAll()` 方法是通过操作系统的线程同步原语来实现的。具体来说，它们依赖于操作系统提供的互斥锁（Mutex）和条件变量（Condition Variable）。

#### 2. 源码层面的实现



`wait()` 方法在 `Object` 类中的声明如下：













```java
public final native void wait() throws InterruptedException;
```



可以看到，`wait()` 方法是一个本地方法（`native`），其具体实现是在 JVM 的底层代码（通常是用 C++ 编写）中完成的。以下是大致的底层实现逻辑：













```c++
// 简化的 JVM 底层实现逻辑
void ObjectMonitor::wait(jlong millis, bool interruptible, TRAPS) {
    Thread * const Self = THREAD;
    // 检查线程是否持有监视器锁
    if (!Self->is_lock_owned((address) this)) {
        THROW(vmSymbols::java_lang_IllegalMonitorStateException());
    }
    // 释放监视器锁
    exit(Self, true, THREAD);
    // 将线程加入等待集合
    ObjectWaiter node(Self);
    node.TState = ObjectWaiter::TS_WAIT;
    AddWaiter(&node);
    // 挂起线程
    if (millis > 0) {
        Self->_ParkEvent->park(millis);
    } else {
        Self->_ParkEvent->park();
    }
    // 线程被唤醒后，重新竞争监视器锁
    if (interruptible && Thread::is_interrupted(Self, true)) {
        // 处理中断
    }
    enter(Self, THREAD);
}
```



上述代码是简化的实现，实际的 JVM 代码要复杂得多。其主要步骤如下：



1. **检查线程是否持有监视器锁**：如果线程没有持有该对象的监视器锁，会抛出 `IllegalMonitorStateException` 异常。
2. **释放监视器锁**：调用 `exit()` 方法释放当前线程持有的监视器锁，使得其他线程可以获取该锁。
3. **将线程加入等待集合**：创建一个 `ObjectWaiter` 对象表示当前线程，并将其加入到对象的等待集合中。
4. **挂起线程**：使用操作系统的线程挂起机制（如 `park()` 方法）将线程挂起，使其进入等待状态。
5. **线程被唤醒**：当其他线程调用 `notify()` 或 `notifyAll()` 方法时，等待的线程会被唤醒。
6. **重新竞争监视器锁**：线程被唤醒后，会调用 `enter()` 方法重新竞争该对象的监视器锁，只有获取到锁后才能继续执行后续代码。

### 示例代码



以下是一个简单的 Java 示例，展示了 `wait()` 和 `notify()` 方法的使用：






```java
public class WaitNotifyExample {
    public static void main(String[] args) {
        final Object lock = new Object();

        // 等待线程
        Thread waitingThread = new Thread(() -> {
            synchronized (lock) {
                try {
                    System.out.println("Waiting thread is waiting...");
                    lock.wait();
                    System.out.println("Waiting thread is awakened.");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        // 唤醒线程
        Thread notifyingThread = new Thread(() -> {
            synchronized (lock) {
                try {
                    Thread.sleep(2000);
                    System.out.println("Notifying thread is notifying...");
                    lock.notify();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        waitingThread.start();
        notifyingThread.start();
    }
}
```



在这个示例中，`waitingThread` 调用 `lock.wait()` 方法进入等待状态，`notifyingThread` 在 2 秒后调用 `lock.notify()` 方法唤醒 `waitingThread`。



综上所述，`Object` 类的 `wait()` 方法通过 Java 的监视器锁和等待集合机制，结合操作系统的线程同步原语，实现了线程间的等待和唤醒功能。  

## sleep和yield为什么是静态的

Thread 类的 sleep()和 yield()方法将在当前正在执行的线程上运行。所以在其他
处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静
态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在
其他非运行线程调用这些方法。

## 为什么wait，notify和notifyall不在thread中
一个很明显的原因是 JAVA 提供的锁是对象级的而不是线程级的，每个对象都有
锁，通过线程获得。由于 wait，notify 和 notifyAll 都是锁级别的操作，所以把他
们定义在 Object 类中因为锁属于对象。

## 乐观锁和悲观锁实现

**悲观锁**：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每

次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传

统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写

锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关

键字的实现也是悲观锁。

**乐观锁**：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所

以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，

可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，

像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。在 Java

中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实

现方式 CAS 实现的。

**乐观锁的实现方式**：

1、使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标

识，不一致时可以采取丢弃和再次尝试的策略。

2、java 中的 Compare and Swap 即 CAS ，当多个线程尝试使用 CAS 同时更新

同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的

线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。 CAS 操作

中包含三个操作数 ―― 需要读写的内存位置（V）、进行比较的预期原值（A）

和拟写入的新值(B)。如果内存位置 V 的值与预期原值 A 相匹配，那么处理器会自

动将该位置值更新为新值 B。否则处理器不做任何操作。

**CAS 缺点**：

1、**ABA 问题**：

比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中

取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，

这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线

程 one 的 CAS 操作成功，但可能存在潜藏的问题。从 Java1.5 开始 JDK 的 atomic

包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。

2、**循环时间长开销大**：

对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪

费更多的 CPU 资源，效率低于 synchronized。

3、**只能保证一个共享变量的原子操作**：

当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，

但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可

以用锁。

## 死锁，活锁，饿死

死锁、活锁、饥饿是关于多线程是否活跃出现的运行阻塞障碍问题，如果线程出现

了这三种情况，即线程不再活跃，不能再正常地执行下去了。

**死锁**

死锁是多线程中最差的一种情况，多个线程相互占用对方的资源的锁，而又相互等

对方释放锁，此时若无外力干预，这些线程则一直处理阻塞的假死状态，形成死锁。

举个例子，A 同学抢了 B 同学的钢笔，B 同学抢了 A 同学的书，两个人都相互占

用对方的东西，都在让对方先还给自己自己再还，这样一直争执下去等待对方还而

又得不到解决，老师知道此事后就让他们相互还给对方，这样在外力的干预下他们

才解决，当然这只是个例子没有老师他们也能很好解决，计算机不像人如果发现这

种情况没有外力干预还是会一直阻塞下去的。

**活锁**

活锁这个概念大家应该很少有人听说或理解它的概念，而在多线程中这确实存在。

活锁恰恰与死锁相反，死锁是大家都拿不到资源都占用着对方的资源，而活锁是拿

到资源却又相互释放不执行。当多线程中出现了相互谦让，都主动将资源释放给别

的线程使用，这样这个资源在多个线程之间跳动而又得不到执行，这就是活锁。

**饥饿**

我们知道多线程执行中有线程优先级这个东西，优先级高的线程能够插队并优先执

行，这样如果优先级高的线程一直抢占优先级低线程的资源，导致低优先级线程无

法得到执行，这就是饥饿。当然还有一种饥饿的情况，一个线程一直占着一个资源

不放而导致其他线程得不到执行，与死锁不同的是饥饿在以后一段时间内还是能够

得到执行的，如那个占用资源的线程结束了并释放了资源。

**无锁**

无锁，即没有对资源进行锁定，即所有的线程都能访问并修改同一个资源，但同时

只有一个线程能修改成功。无锁典型的特点就是一个修改操作在一个循环内进行，

线程会不断的尝试修改共享资源，如果没有冲突就修改成功并退出否则就会继续下

一次循环尝试。所以，如果有多个线程修改同一个值必定会有一个线程能修改成功，

而其他修改失败的线程会不断重试直到修改成功。之前的文章我介绍过 JDK 的

CAS 原理及应用即是无锁的实现。

可以看出，无锁是一种非常良好的设计，它不会出现线程出现的跳跃性问题，锁使

用不当肯定会出现系统性能问题，虽然无锁无法全面代替有锁，但无锁在某些场合

下是非常高效的。

