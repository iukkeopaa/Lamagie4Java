### 定义和基本概念



- **守护线程（Daemon Thread）**：是一种在后台运行的线程，主要用于为其他线程提供服务，比如垃圾回收线程就是典型的守护线程。当 Java 虚拟机中只剩下守护线程时，虚拟机将自动退出，因为守护线程不会阻止程序的终止。
- **本地线程（这里可能你想问的是用户线程，即非守护线程）**：是用户显式创建并启动的线程，用于执行具体的业务逻辑。用户线程的执行会阻止 Java 虚拟机的退出，只有当所有用户线程都执行完毕后，虚拟机才会退出。

### 区别对比

#### 1. 生命周期



- **守护线程**：其生命周期依赖于用户线程。当所有用户线程执行完毕后，即使守护线程的任务还未完成，Java 虚拟机也会强制终止守护线程并退出。
- **用户线程**：用户线程的生命周期完全由其自身的执行逻辑决定，只有当线程的任务执行完毕或者抛出未捕获的异常时，线程才会结束。只要有一个用户线程在运行，Java 虚拟机就不会退出。

#### 2. 创建和设置方式



- **守护线程**：在创建线程对象后，需要调用 `setDaemon(true)` 方法将其设置为守护线程，并且这个设置操作必须在调用 `start()` 方法之前进行，否则会抛出 `IllegalThreadStateException` 异常。



java











```java
Thread daemonThread = new Thread(() -> {
    while (true) {
        try {
            Thread.sleep(1000);
            System.out.println("守护线程正在运行");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
});
daemonThread.setDaemon(true);
daemonThread.start();
```



- **用户线程**：创建和启动线程的方式与普通线程相同，不需要额外的设置。



java











```java
Thread userThread = new Thread(() -> {
    try {
        Thread.sleep(3000);
        System.out.println("用户线程执行完毕");
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
});
userThread.start();
```

#### 3. 用途



- **守护线程**：通常用于执行一些后台任务，如垃圾回收、内存管理、日志记录等。这些任务不需要保证在程序结束时一定完成，只要在程序运行期间提供相应的服务即可。
- **用户线程**：主要用于执行具体的业务逻辑，如文件处理、网络请求、数据库操作等。这些任务是程序的核心功能，需要保证其执行的完整性。

#### 4. 终止机制



- **守护线程**：由于其生命周期依赖于用户线程，当所有用户线程终止时，守护线程会被 Java 虚拟机强制终止，不会进行正常的资源清理操作。因此，守护线程中不适合进行一些需要确保资源释放的操作，如文件关闭、数据库连接关闭等。
- **用户线程**：用户线程可以通过正常的线程执行结束、抛出异常或者调用 `interrupt()` 方法来终止。在终止时，可以进行必要的资源清理操作，保证程序的稳定性。