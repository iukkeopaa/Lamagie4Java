### 性能问题


第一，既然使用锁会带来性能问题，那最好的方案自然就是使用无锁的算法和数据结构了。
在这方面有很多相关的技术，例如线程本地存储 (Thread Local Storage, TLS)、写入时复
制 (Copy-on-write)、乐观锁等；Java 并发包里面的原子类也是一种无锁的数据结构；
Disruptor 则是一个无锁的内存队列，性能都非常好……
第二，减少锁持有的时间。互斥锁本质上是将并行的程序串行化，所以要增加并行度，一定
要减少持有锁的时间。这个方案具体的实现技术也有很多，例如使用细粒度的锁，一个典型
的例子就是 Java 并发包里的 ConcurrentHashMap，它使用了所谓分段锁的技术（这个技
术后面我们会详细介绍）；还可以使用读写锁，也就是读是无锁的，只有写的时候才会互
斥。


性能方面的度量指标有很多，我觉得有三个指标非常重要，就是：吞吐量、延迟和并发量。
1. 吞吐量：指的是单位时间内能处理的请求数量。吞吐量越高，说明性能越好。
2. 延迟：指的是从发出请求到收到响应的时间。延迟越小，说明性能越好
3. 并发量：指的是能同时处理的请求数量，一般来说随着并发量的增加、延迟也会增加。
   所以延迟这个指标，一般都会是基于并发量来说的。例如并发量是 1000 的时候，延迟
   是 50 毫秒

