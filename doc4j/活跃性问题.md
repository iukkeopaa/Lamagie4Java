### 活跃性问题


所谓活跃性问题，指的是某个操作无法执行下去。我们常见的“死锁”就是一种典型的活跃
性问题，当然除了死锁外，还有两种情况，分别是“活锁”和“饥饿”。


通过前面的学习你已经知道，发生“死锁”后线程会互相等待，而且会一直等待下去，在技
术上的表现形式是线程永久地“阻塞”了。
但有时线程虽然没有发生阻塞，但仍然会存在执行不下去的情况，这就是所谓的“活锁”。
可以类比现实世界里的例子，路人甲从左手边出门，路人乙从右手边进门，两人为了不相
撞，互相谦让，路人甲让路走右手边，路人乙也让路走左手边，结果是两人又相撞了。这种
情况，基本上谦让几次就解决了，因为人会交流啊。可是如果这种情况发生在编程世界了，
就有可能会一直没完没了地“谦让”下去，成为没有发生阻塞但依然执行不下去的“活
锁”。


### 活锁


解决“活锁”的方案很简单，谦让时，尝试等待一个随机的时间就可以了。例如上面的那个
例子，路人甲走左手边发现前面有人，并不是立刻换到右手边，而是等待一个随机的时间
后，再换到右手边；同样，路人乙也不是立刻切换路线，也是等待一个随机的时间再切换。
由于路人甲和路人乙等待的时间是随机的，所以同时相撞后再次相撞的概率就很低了。“等
待一个随机时间”的方案虽然很简单，却非常有效，Raft 这样知名的分布式一致性算法中
也用到了它


### 饥饿

那“饥饿”该怎么去理解呢？所谓“饥饿”指的是线程因无法访问所需资源而无法执行下去
的情况。“不患寡，而患不均”，如果线程优先级“不均”，在 CPU 繁忙的情况下，优先
级低的线程得到执行的机会很小，就可能发生线程“饥饿”；持有锁的线程，如果执行的时
间过长，也可能导致“饥饿”问题。
解决“饥饿”问题的方案很简单，有三种方案：一是保证资源充足，二是公平地分配资源，
三就是避免持有锁的线程长时间执行。这三个方案中，方案一和方案三的适用场景比较有
限，因为很多场景下，资源的稀缺性是没办法解决的，持有锁的线程执行的时间也很难缩
短。倒是方案二的适用场景相对来说更多一些。

那如何公平地分配资源呢？在并发编程里，主要是使用公平锁。所谓公平锁，是一种先来后
到的方案，线程的等待是有顺序的，排在等待队列前面的线程会优先获得资源