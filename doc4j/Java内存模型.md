### Java内存模型

你已经知道，导致可见性的原因是缓存，导致有序性的原因是编译优化，那解决可见性、有
序性最直接的办法就是禁用缓存和编译优化，但是这样问题虽然解决了，我们程序的性能可
就堪忧了。
合理的方案应该是按需禁用缓存以及编译优化。那么，如何做到“按需禁用”呢？对于并发
程序，何时禁用缓存以及编译优化只有程序员知道，那所谓“按需禁用”其实就是指按照程
序员的要求来禁用。所以，为了解决可见性和有序性问题，只需要提供给程序员按需禁用缓
存和编译优化的方法即可。Java 内存模型是个很复杂的规范，可以从不同的视角来解读，站在我们这些程序员的视
角，本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方
法。具体来说，这些方法包括 volatile、synchronized 和 final 三个关键字，以及六项
Happens-Before 规则



### volatile

volatile 关键字并不是 Java 语言的特产，古老的 C 语言里也有，它最原始的意义就是禁用
CPU 缓存。

例如，我们声明一个 volatile 变量 volatile int x = 0，它表达的是：告诉编译器，
对这个变量的读写，不能使用 CPU 缓存，必须从内存中读取或者写入。这个语义看上去相
当明确，但是在实际使用的时候却会带来困惑。


**注意** volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。

### 如何禁止指令重排序

在 Java 中，volatile 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。 如果我们将变量声明为 volatile ，在对这个变量进行读写操作的时候，会通过插入特定的 内存屏障 的方式来禁止指令重排序。

    public native void loadFence();public native void storeFence();public native void fullFence();


### volatile无法保证原子性的解决方案

1. 使用synchronized关键字
2. 使用Lock
3. 使用AtomicInterger原子类